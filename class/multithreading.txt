Threads allow you to develop more efficient applications synchronizing through the shared memory.
1. Process - Process is what the operating system uses to facilitate the execution of a program by providing the resources required.
 Each process has a unique process Id associated with it. You can view the process within which a program is being executed using windows task manager.
2. Thread - Thread is a light weight process. A process has at least one thread which is commonly called as main thread which actually executes the application code.
 A single process can have multiple threads.

All the threading related classes are present in System.Threading namespace.
Advantages of multithreading:
1. To maintain a responsive user interface
2. To make efficient use of processor time while waiting for I/O operations to complete.
3. To split large, CPU-bound tasks to be processed simultaneously on a machine that has multiple CPUs/cores. 

Disadvantages of multithreading:
1. On a single-core/processor machine threading can affect performance negatively as there is overhead involved with context-switching.
2. Have to write more lines of code to accomplish the same task.
3. Multithreaded applications are difficult to write, understand, debug and maintain.
Why we should not use threads in our applications?

Creating and destroying a thread is costly process it takes processor time. Several things must be performed while creating
1.	Operating system must go in to kernel mode.
2.	Other threads must notify the new thread is created.
3.	Operating system must leave the kernel mode. Etc.

From the developers point of view
1.	Multithreading applications are hard to debug.
2.	And makes the application more complex.
3.	class Program
    {
        static void Main(string[] args)
        {
            // create thread start delegate instance - contains the method to execute by the thread
            ThreadStart ts = new ThreadStart(run);
            // create new thread
            Thread thrd = new Thread(ts);
            // start thread
            thrd.Start();
4.	            // makes the main thread sleep - let sub thread to run
            Thread.Sleep(1000);
5.	            for (int t = 10; t > 0; t--)
            {
                Console.WriteLine("Main Thread value is :" + t);
                Thread.Sleep(1000);
            }

           Console.WriteLine("Good Bye!!!I'm main Thread");
           Console.ReadLine();
6.	         }
7.	        // this method executed by a separate thread
        static void run()
        {
            for (int i = 0; i < 10; i++)
            {
                Console.WriteLine("Sub Thread value is : " + i);
                Thread.Sleep(1000);
            }
            Console.WriteLine("Good Bye!!!I'm Sub Thread");
        }
   }


A thread is defined as the execution path of a program. Each thread defines a unique flow of control. 
If your application involves complicated and time consuming operations, then it is often helpful to set different execution paths or threads,
with each thread performing a particular job.
Threads are lightweight processes. One common example of use of thread is implementation of concurrent programming by modern operating systems. 
Use of threads saves wastage of CPU cycle and increase efficiency of an application.
So far we wrote the programs where a single thread runs as a single process which is the running instance of the application. 
However, this way the application can perform one job at a time. To make it execute more than one task at a time, it could be divided into smaller threads.

Thread Life Cycle
The life cycle of a thread starts when an object of the System.Threading.Thread class is created and ends when the thread is terminated or completes execution.
Following are the various states in the life cycle of a thread:
The Unstarted State: It is the situation when the instance of the thread is created but the Start method is not called.
The Ready State: It is the situation when the thread is ready to run and waiting CPU cycle.
The Not Runnable State: A thread is not executable, when:
Sleep method has been called
Wait method has been called
Blocked by I/O operations
The Dead State: It is the situation when the thread completes execution or is aborted.

Creating Threads--
Threads are created by extending the Thread class. The extended Thread class then calls the Start() method to begin the child thread execution.
The following program demonstrates the concept:

using System;
using System.Threading;

namespace MultithreadingApplication
{
   class ThreadCreationProgram
   {
      public static void CallToChildThread()
      {
         Console.WriteLine("Child thread starts");
      }
      
      static void Main(string[] args)
      {
         ThreadStart childref = new ThreadStart(CallToChildThread);
         Console.WriteLine("In Main: Creating the Child thread");
         Thread childThread = new Thread(childref);
         childThread.Start();
         Console.ReadKey();
      }
   }
}
When the above code is compiled and executed, it produces the following result:

In Main: Creating the Child thread
Child thread starts

Managing Threads--
The Thread class provides various methods for managing threads.
The following example demonstrates the use of the sleep() method for making a thread pause for a specific period of time.

using System;
using System.Threading;

namespace MultithreadingApplication
{
   class ThreadCreationProgram
   {
      public static void CallToChildThread()
      {
         Console.WriteLine("Child thread starts");
         
         // the thread is paused for 5000 milliseconds
         int sleepfor = 5000; 
         
         Console.WriteLine("Child Thread Paused for {0} seconds", sleepfor / 1000);
         Thread.Sleep(sleepfor);
         Console.WriteLine("Child thread resumes");
      }
      
      static void Main(string[] args)
      {
         ThreadStart childref = new ThreadStart(CallToChildThread);
         Console.WriteLine("In Main: Creating the Child thread");
         Thread childThread = new Thread(childref);
         childThread.Start();
         Console.ReadKey();
      }
   }
}
When the above code is compiled and executed, it produces the following result:

In Main: Creating the Child thread
Child thread starts
Child Thread Paused for 5 seconds
Child thread resumes

Destroying Threads--
The Abort() method is used for destroying threads.
The runtime aborts the thread by throwing a ThreadAbortException. This exception cannot be caught, the control is sent to the finally block, if any.

The following program illustrates this:

using System;
using System.Threading;

namespace MultithreadingApplication
{
   class ThreadCreationProgram
   {
      public static void CallToChildThread()
      {
         try
         {
            Console.WriteLine("Child thread starts");
            
            // do some work, like counting to 10
            for (int counter = 0; counter <= 10; counter++)
            {
               Thread.Sleep(500);
               Console.WriteLine(counter);
            }
            
            Console.WriteLine("Child Thread Completed");
         }
         
         catch (ThreadAbortException e)
         {
            Console.WriteLine("Thread Abort Exception");
         }
         finally
         {
            Console.WriteLine("Couldn't catch the Thread Exception");
         }
      }
      
      static void Main(string[] args)
      {
         ThreadStart childref = new ThreadStart(CallToChildThread);
         Console.WriteLine("In Main: Creating the Child thread");
         Thread childThread = new Thread(childref);
         childThread.Start();
         
         //stop the main thread for some time
         Thread.Sleep(2000);
         
         //now abort the child
         Console.WriteLine("In Main: Aborting the Child thread");
         
         childThread.Abort();
         Console.ReadKey();
      }
   }
}
When the above code is compiled and executed, it produces the following result:

In Main: Creating the Child thread
Child thread starts
0
1
2
In Main: Aborting the Child thread
Thread Abort Exception
Couldn't catch the Thread Exception 